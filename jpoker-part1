
//     Copyright (C) 2008 - 2010 Loic Dachary <loic@dachary.org>
//     Copyright (C) 2008 - 2010 Johan Euphrosine <proppy@aminche.com>
//     Copyright (C) 2008, 2009 Saq Imtiaz <lewcid@gmail.com>
//
//     This program is free software: you can redistribute it and/or modify
//     it under the terms of the GNU General Public License as published by
//     the Free Software Foundation, either version 3 of the License, or
//     (at your option) any later version.
//
//     This program is distributed in the hope that it will be useful,
//     but WITHOUT ANY WARRANTY; without even the implied warranty of
//     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//     GNU General Public License for more details.
//
//     You should have received a copy of the GNU General Public License
//     along with this program.  If not, see <http://www.gnu.org/licenses/>.
//

(function($) {
    var _ = $.gt.gettext;

    if(!String.prototype.supplant) {
        //
        // Douglas Crockford douglas@crockford.com snippet
        //
        String.prototype.supplant = function (o) {
            return this.replace(/{([^{}]*)}/g,
                                function (a, b) {
                                    var r = o[b];
                                    return typeof r === 'string' || typeof r === 'number' ? r : a;
                                }
                                );
        };
    }

    //
    // decoration divs to help CSS skining
    // example $('.jpoker_download', copyright).frame('box1');
    //
    $.fn.extend({
            frame: function(css) {
                var box = '';
                var positions = [ 'n', 'e', 's', 'w', 'se', 'sw', 'nw', 'ne' ];
                for(var i = 0; i < positions.length; i++) {
                    box += '<div style=\'position: absolute\' class=\'' + css + ' ' + css + '-' + positions[i] + '\'></div>';
                }
                var toggle = function() { $(this).toggleClass(css + '-hover'); };

                return this.each(function() {
                        var $this = $(this);
                        $this.wrap('<div style=\'position: relative\' class=\'' + css + ' ' + css + '-container\'></div>');
                        $this.parent().hover(toggle, toggle);
                        $this.after(box);
                        $this.wrap('<div class=\'' + css + ' ' + css + '-inner\'></div>');
                        return this;
                    });
            }
        });

    $.fn.jpoker = function() {
        var args = Array.prototype.slice.call(arguments);
        var name = args.shift();
        $.jpoker.plugins[name].apply(this, args);
    };

    $.jpoker = {

        jpoker_version: '2.0.0',

        jpoker_sources: 'http://jspoker.pokersource.info/packaging-farm/jpoker/gnulinux/debian/squeeze/src/jpoker_{jpoker-version}.orig.tar.gz',

        poker_network_version: '2.0.0',

        poker_network_sources: 'http://farmpoker.pokersource.info/packaging-farm/poker-network/gnulinux/debian/squeeze/src/poker-network_{poker-network-version}.orig.tar.gz',

        sound: 'embed width=\'1\' height=\'1\' pluginspage=\'http://getgnash.org/\' type=\'application/x-shockwave-flash\' ',

        sound_directory: '',

        packetName2Type: { NONE: 0, STRING: 1, INT: 2, ERROR: 3, ACK: 4, PING: 5, SERIAL: 6, QUIT: 7, AUTH_OK: 8, AUTH_REFUSED: 9, LOGIN: 10, AUTH_REQUEST: 11, LIST: 12, LOGOUT: 13, BOOTSTRAP: 14, PROTOCOL_ERROR: 15, MESSAGE: 16, POKER_SEATS: 50, POKER_ID: 51, POKER_MESSAGE: 52, ERROR: 53, POKER_POSITION: 54, POKER_INT: 55, POKER_BET: 56, POKER_FOLD: 57, POKER_STATE: 58, POKER_WIN: 59, POKER_CARDS: 60, POKER_PLAYER_CARDS: 61, POKER_BOARD_CARDS: 62, POKER_CHIPS: 63, POKER_PLAYER_CHIPS: 64, POKER_CHECK: 65, POKER_START: 66, POKER_IN_GAME: 67, POKER_CALL: 68, POKER_RAISE: 69, POKER_DEALER: 70, POKER_TABLE_JOIN: 71, POKER_TABLE_SELECT: 72, POKER_TABLE: 73, POKER_TABLE_LIST: 74, POKER_SIT: 75, POKER_TABLE_DESTROY: 76, POKER_TIMEOUT_WARNING: 77, POKER_TIMEOUT_NOTICE: 78, POKER_SEAT: 79, POKER_TABLE_MOVE: 80, POKER_PLAYER_LEAVE: 81, POKER_SIT_OUT: 82, POKER_TABLE_QUIT: 83, POKER_BUY_IN: 84, POKER_REBUY: 85, POKER_CHAT: 86, POKER_PLAYER_INFO: 87, POKER_PLAYER_ARRIVE: 88, POKER_HAND_SELECT: 89, POKER_HAND_LIST: 90, POKER_HAND_SELECT_ALL: 91, POKER_USER_INFO: 92, POKER_GET_USER_INFO: 93, POKER_ANTE: 94, POKER_BLIND: 95, POKER_WAIT_BIG_BLIND: 96, POKER_AUTO_BLIND_ANTE: 97, POKER_NOAUTO_BLIND_ANTE: 98, POKER_CANCELED: 99, POKER_BLIND_REQUEST: 100, POKER_ANTE_REQUEST: 101, POKER_AUTO_FOLD: 102, POKER_WAIT_FOR: 103, POKER_STREAM_MODE: 104, POKER_BATCH_MODE: 105, POKER_LOOK_CARDS: 106, POKER_TABLE_REQUEST_PLAYERS_LIST: 107, POKER_PLAYERS_LIST: 108, POKER_PERSONAL_INFO: 109, POKER_GET_PERSONAL_INFO: 110, POKER_TOURNEY_SELECT: 111, POKER_TOURNEY: 112, POKER_TOURNEY_INFO: 113, POKER_TOURNEY_LIST: 114, POKER_TOURNEY_REQUEST_PLAYERS_LIST: 115, POKER_TOURNEY_REGISTER: 116, POKER_TOURNEY_UNREGISTER: 117, POKER_TOURNEY_PLAYERS_LIST: 118, POKER_HAND_HISTORY: 119, POKER_SET_ACCOUNT: 120, POKER_CREATE_ACCOUNT: 121, POKER_PLAYER_SELF: 122, POKER_GET_PLAYER_INFO: 123, POKER_ROLES: 124, POKER_SET_ROLE: 125, POKER_READY_TO_PLAY: 126, POKER_PROCESSING_HAND: 127, POKER_MUCK_REQUEST: 128, POKER_AUTO_MUCK: 129, POKER_MUCK_ACCEPT: 130, POKER_MUCK_DENY: 131, POKER_CASH_IN: 132, POKER_CASH_OUT: 133, POKER_CASH_OUT_COMMIT: 134, POKER_CASH_QUERY: 135, POKER_RAKE: 136, POKER_TOURNEY_RANK: 137, POKER_PLAYER_IMAGE: 138, POKER_GET_PLAYER_IMAGE: 139, POKER_HAND_REPLAY: 140, POKER_GAME_MESSAGE: 141, POKER_EXPLAIN: 142, POKER_STATS_QUERY: 143, POKER_STATS: 144, PACKET_POKER_PLAYER_PLACES: 152, PACKET_POKER_SET_LOCALE: 153, POKER_TABLE_PICKER: 165, PACKET_POKER_BEST_CARDS: 170, PACKET_POKER_POT_CHIPS: 171, PACKET_POKER_CLIENT_ACTION: 172, PACKET_POKER_BET_LIMIT: 173, POKER_SIT_REQUEST: 174, POKER_PLAYER_NO_CARDS: 175, PACKET_POKER_CHIPS_PLAYER2BET: 176, PACKET_POKER_CHIPS_BET2POT: 177, PACKET_POKER_CHIPS_POT2PLAYER: 178, PACKET_POKER_CHIPS_POT_MERGE: 179, POKER_CHIPS_POT_RESET: 180, POKER_CHIPS_BET2PLAYER: 181, POKER_END_ROUND: 182, PACKET_POKER_DISPLAY_NODE: 183, PACKET_POKER_DEAL_CARDS: 184, POKER_CHAT_HISTORY: 185, POKER_DISPLAY_CARD: 186, POKER_SELF_IN_POSITION: 187, POKER_SELF_LOST_POSITION: 188, POKER_HIGHEST_BET_INCREASE: 189, POKER_PLAYER_WIN: 190, POKER_ANIMATION_PLAYER_NOISE: 191, POKER_ANIMATION_PLAYER_FOLD: 192, POKER_ANIMATION_PLAYER_BET: 193, POKER_ANIMATION_PLAYER_CHIPS: 194, POKER_ANIMATION_DEALER_CHANGE: 195, POKER_ANIMATION_DEALER_BUTTON: 196, POKER_BEGIN_ROUND: 197, POKER_CURRENT_GAMES: 198, POKER_END_ROUND_LAST: 199, POKER_PYTHON_ANIMATION: 200, POKER_SIT_OUT_NEXT_TURN: 201, POKER_RENDERER_STATE: 202, POKER_CHAT_WORD: 203, POKER_SHOWDOWN: 204, POKER_CLIENT_PLAYER_CHIPS: 205, POKER_INTERFACE_COMMAND: 206, POKER_PLAYER_ME_LOOK_CARDS: 207, POKER_PLAYER_ME_IN_FIRST_PERSON: 208, POKER_ALLIN_SHOWDOWN: 209, POKER_PLAYER_HAND_STRENGTH: 210 },

        verbose: 0,

        doReconnect: true,
        doReconnectAlways: false,
        doRejoin: true,

        msie_compatibility: function() {
            /*
             *  On IE, the widget container width and height needs to be set explicitly
             *  if the widget width/height is being set as 'none'
             */
            this.dialog_options.containerWidth = '300px';
            this.dialog_options.containerHeight = '200px';

            this.error_dialog_options.containerWidth = '300px';
            this.error_dialog_options.containerHeight = '200px';

            this.plugins.playerSelf.rebuy_options.containerWidth = '300px';
            this.plugins.playerSelf.rebuy_options.containerHeight = '200px';

            this.copyright_options.containerWidth = '400px';
            this.copyright_options.containerHeight = '300px';

            this.plugins.table.rank.options.containerWidth = '300px';
            this.plugins.table.rank.options.containerHeight = '200px';
        },

        other_compatibility: function() {
            /*
             *  On IE, the widget container width and height needs to be set explicitly
             *  if the widget width/height is being set as 'none'
             */
            this.dialog_options.containerWidth = '100%';
            this.dialog_options.containerHeight = '100%';

            this.plugins.playerSelf.rebuy_options.containerWidth = '100%';
            this.plugins.playerSelf.rebuy_options.containerHeight = '100%';

            this.copyright_options.containerWidth = '100%';
            this.copyright_options.containerHeight = '100%';

            this.plugins.table.rank.options.containerWidth = '100%';
            this.plugins.table.rank.options.containerHeight = '100%';
        },

        copyrightTimeout: 5000,

        copyright_options: { width: 'none', height: 'none' },

        copyright_template: '<div id=\'jpoker_copyright\'><div class=\'jpoker_copyright_image\'></div><div class=\'jpoker_software\'>jpoker-{jpoker-version} and poker-network-{poker-network-version}</div><div class=\'jpoker_authors\'><div><span>Copyright 1993-2010 Loic Dachary, Johan Euphrosine and <a onclick=\'window.open(this.href); return false\' href=\'http://pokersource.eu/#Copyright\'>al.</a></div></div><div class=\'jpoker_license\'>This program is free software: you can redistribute it and/or modify it under the terms of the <a onclick=\'window.open(this.href); return false\' href=\'http://www.fsf.org/licensing/licenses/gpl.txt\'>GNU General Public License</a> and <a onclick=\'window.open(this.href); return false\' href=\'http://www.fsf.org/licensing/licenses/agpl.txt\'>GNU Affero General Public License</a> as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.</div> <div class=\'jpoker_download\'>Download <a onclick=\'window.open(this.href); return false\' href=\'{jpoker-sources}\'>jpoker sources</a> and <a onclick=\'window.open(this.href); return false\' href=\'{poker-network-sources}\'>poker-network sources</a><div class=\'jpoker_outflop_image\'></div><div class=\'jpoker_outflop\'>OutFlop provides services and software to create and operate multiplayer online poker rooms. Our expertise ranges from web based solutions well suited to local businesses up to large scale, international operations. Learn more about <a onclick=\'window.open(this.href); return false\' href=\'http://outflop.me\'>OutFlop poker software</a></div></div>',

        copyright_text: 'replaced by copyright_template with substitutions',

        copyright: function() {
            /*
             * On IE7, css('margin') returns 'auto' instead of the actual margin value unless
             * the  margin is set explicitly. This causes ui.dialog to throw exceptions.
             */
            var copyright = $('<div style=\'margin:0px\'>' + this.copyright_text + '<div class=\'jpoker_dismiss\'><a href=\'javascript://\'>Dismiss</a></div></div>').dialog(this.copyright_options);
            this.copyright_callback.display_done(copyright);
            $('.ui-dialog-titlebar', copyright.parents('.ui-dialog-container')).hide();
            var close = function() { copyright.dialog('destroy'); };
            window.setTimeout(close, this.copyrightTimeout);
            copyright.click(close);
            return copyright;
        },

        copyright_callback: {
            display_done: function(element) {
            }
        },

        serial: (new Date()).getTime(),

        servers: {},

        url2hashCache: {},

        uninit: function() {
            $.each(this.servers,
                   function(key, value) {
                       value.uninit();
                   });
            this.servers = {};
        },

        quit: function(callback) {
            var server;
            for(var url in this.servers) {
                server = this.servers[url];
                break;
            }
            if(server === undefined) {
                if(callback !== undefined) {
                    callback();
                }
                return true;
            } else {
                server.quit(function(server) {
                        delete jpoker.servers[url];
                        jpoker.quit(callback);
                    });
                return false;
            }
        },

        now: function() { return (new Date()).getTime(); },

        uid: function() { return 'jpoker' + $.jpoker.serial++ ; },

        console : window.console,

        message: function(str) {
            if(jpoker.console) { jpoker.console.log(str); }
        },

        dialog_options: { width: 'none', height: 'none', autoOpen: false, dialog: true, title: 'jpoker message'},

        dialog: function(content) {
            var message = $('#jpokerDialog');
            if(message.size() != 1) {
                $('body').append('<div id=\'jpokerDialog\' class=\'jpoker_jquery_ui\' />');
                message = $('#jpokerDialog');
                if (jpoker.dialog_options.title) {
                    message.attr('title', jpoker.dialog_options.title);
                }
                message.dialog(this.dialog_options);
            }
            message.html(content).dialog('open');
        },

        error: function(reason) {
            var str = '';
            try {
                if (reason.xhr) {
                    // We need to give stringify a whitelist so that it doesn't throw an error if it's called on a
                    // XMLHttpRequest object, and we can't really detect it with instanceof... so let's assume all .xhr
                    // are XMLHttpRequest objects
                    var copy = {};
                    for(var key in reason) {
                        copy[key] = reason[key];
                    }
                    copy.xhr = JSON.stringify(copy.xhr, ['status', 'responseText', 'readyState']);
                    str = JSON.stringify(copy);
                } else {
                    str = JSON.stringify(reason);
                }
                str += '\n\n' + printStackTrace({guess:true}).slice(2).join('\n');
                str += '\n\n' + navigator.userAgent;
            } catch(e) {
                str += 'attempt to stringify failed with exception: ' + e.toString();
            }
            this.uninit();
            this.errorHandler(reason, str);
        },

        error_template: '<span class=\'jquery_error_message\'>{message} <a href="">{retry}</a></span> <div class=\'jquery_error_details\'><pre>{details}</pre></div>',

        error_dialog_options: { width: 'none', height: 'none', autoOpen: false, dialog: true, title: 'jpoker error' },

        errorHandler: function(reason, str) {
            if (jpoker.console) {
                this.message(str);
            }
            var errorDialog = $('#jpokerErrorDialog');
            if(errorDialog.size() === 0) {
                $('body').append('<div id=\'jpokerErrorDialog\' class=\'jpoker_jquery_ui\' />');
                errorDialog = $('#jpokerErrorDialog');
                errorDialog.dialog(jpoker.error_dialog_options);
            }
            var info = { 'details': str,
                         'message': _("Lost connection to the poker server."),
                         'retry': _("Click to retry.")
            };
            errorDialog.html(this.error_template.supplant(info)).dialog('open');
            throw reason;
        },

        serverCreate: function(options) {
            this.servers[options.url] = new jpoker.server(options);
            return this.servers[options.url];
        },

        serverDestroy: function(url) {
            this.servers[url].uninit();
            delete this.servers[url];
        },

        url2server: function(options) {
            if(!(options.url in this.servers)) {
                this.serverCreate(options);
            }
            return this.servers[options.url];
        },

        getServer: function(url) {
            return this.servers[url];
        },

        getTable: function(url, game_id) {
            var server = jpoker.servers[url];
            if(!server) {
                return undefined;
            } else {
                return server.tables[game_id];
            }
        },

        getPlayer: function(url, game_id, serial) {
            var server = jpoker.servers[url];
            if(!server) {
                return undefined;
            }
            var table = server.tables[game_id];
            if(!table) {
                return undefined;
            }
            return table.serial2player[serial];
        },

        getServerTablePlayer: function(url, game_id, serial) {
            var server = jpoker.servers[url];
            if(!server) {
                return undefined;
            }
            var table = server.tables[game_id];
            if(!table) {
                return undefined;
            }
            if(!table.serial2player[serial]) {
                return undefined;
            }
            return { server: server,
                     table: table,
                     player: table.serial2player[serial]
                    };
        },

        url2hash: function(url) {
            if(!(url in this.url2hashCache)) {
                this.url2hashCache[url] = jpoker.Crypto.hexSha1Str(url);
            }
            return this.url2hashCache[url];
        },

        gettext: _
    };

    var jpoker = $.jpoker;

    //--
    //-- Crypto functions and associated conversion routines
    //--

    //
    // Copyright (c) UnaMesa Association 2004-2007
    //
    // Licensed under Modified BSD
    //

    // Crypto namespace
    jpoker.Crypto = function() {};

    // Convert a string to an array of big-endian 32-bit words
    jpoker.Crypto.strToBe32s = function(str)
        {
            var be = Array();
            var len = Math.floor(str.length/4);
            var i, j;
            for(i=0, j=0; i<len; i++, j+=4) {
                be[i] = ((str.charCodeAt(j)&0xff) << 24)|((str.charCodeAt(j+1)&0xff) << 16)|((str.charCodeAt(j+2)&0xff) << 8)|(str.charCodeAt(j+3)&0xff);
            }
            while (j<str.length) {
                be[j>>2] |= (str.charCodeAt(j)&0xff)<<(24-(j*8)%32);
                j++;
            }
            return be;
        };

    // Convert an array of big-endian 32-bit words to a string
    jpoker.Crypto.be32sToStr = function(be)
        {
            var str = '';
            for(var i=0;i<be.length*32;i+=8) {
                str += String.fromCharCode((be[i>>5]>>>(24-i%32)) & 0xff);
            }
            return str;
        };

    // Convert an array of big-endian 32-bit words to a hex string
    jpoker.Crypto.be32sToHex = function(be)
        {
            var hex = '0123456789ABCDEF';
            var str = '';
            for(var i=0;i<be.length*4;i++) {
                str += hex.charAt((be[i>>2]>>((3-i%4)*8+4))&0xF) + hex.charAt((be[i>>2]>>((3-i%4)*8))&0xF);
            }
            return str;
        };

    // Return, in hex, the SHA-1 hash of a string
    jpoker.Crypto.hexSha1Str = function(str)
        {
            return jpoker.Crypto.be32sToHex(jpoker.Crypto.sha1Str(str));
        };

    // Return the SHA-1 hash of a string
    jpoker.Crypto.sha1Str = function(str)
        {
            return jpoker.Crypto.sha1(jpoker.Crypto.strToBe32s(str),str.length);
        };

    // Calculate the SHA-1 hash of an array of blen bytes of big-endian 32-bit words
    jpoker.Crypto.sha1 = function(x,blen)
        {
            // Add 32-bit integers, wrapping at 32 bits
            add32 = function(a,b)
            {
                var lsw = (a&0xFFFF)+(b&0xFFFF);
                var msw = (a>>16)+(b>>16)+(lsw>>16);
                return (msw<<16)|(lsw&0xFFFF);
            };
            // Add five 32-bit integers, wrapping at 32 bits
            add32x5 = function(a,b,c,d,e)
            {
                var lsw = (a&0xFFFF)+(b&0xFFFF)+(c&0xFFFF)+(d&0xFFFF)+(e&0xFFFF);
                var msw = (a>>16)+(b>>16)+(c>>16)+(d>>16)+(e>>16)+(lsw>>16);
                return (msw<<16)|(lsw&0xFFFF);
            };
            // Bitwise rotate left a 32-bit integer by 1 bit
            rol32 = function(n)
            {
                return (n>>>31)|(n<<1);
            };

            var len = blen*8;
            // Append padding so length in bits is 448 mod 512
            x[len>>5] |= 0x80 << (24-len%32);
            // Append length
            x[((len+64>>9)<<4)+15] = len;
            var w = Array(80);

            var k1 = 0x5A827999;
            var k2 = 0x6ED9EBA1;
            var k3 = 0x8F1BBCDC;
            var k4 = 0xCA62C1D6;

            var h0 = 0x67452301;
            var h1 = 0xEFCDAB89;
            var h2 = 0x98BADCFE;
            var h3 = 0x10325476;
            var h4 = 0xC3D2E1F0;

            for(var i=0;i<x.length;i+=16) {
                var j,t;
                var a = h0;
                var b = h1;
                var c = h2;
                var d = h3;
                var e = h4;
                for(j = 0;j<16;j++) {
                    w[j] = x[i+j];
                    t = add32x5(e,(a>>>27)|(a<<5),d^(b&(c^d)),w[j],k1);
                    e=d; d=c; c=(b>>>2)|(b<<30); b=a; a = t;
                }
                for(j=16;j<20;j++) {
                    w[j] = rol32(w[j-3]^w[j-8]^w[j-14]^w[j-16]);
                    t = add32x5(e,(a>>>27)|(a<<5),d^(b&(c^d)),w[j],k1);
                    e=d; d=c; c=(b>>>2)|(b<<30); b=a; a = t;
                }
                for(j=20;j<40;j++) {
                    w[j] = rol32(w[j-3]^w[j-8]^w[j-14]^w[j-16]);
                    t = add32x5(e,(a>>>27)|(a<<5),b^c^d,w[j],k2);
                    e=d; d=c; c=(b>>>2)|(b<<30); b=a; a = t;
                }
                for(j=40;j<60;j++) {
                    w[j] = rol32(w[j-3]^w[j-8]^w[j-14]^w[j-16]);
                    t = add32x5(e,(a>>>27)|(a<<5),(b&c)|(d&(b|c)),w[j],k3);
                    e=d; d=c; c=(b>>>2)|(b<<30); b=a; a = t;
                }
                for(j=60;j<80;j++) {
                    w[j] = rol32(w[j-3]^w[j-8]^w[j-14]^w[j-16]);
                    t = add32x5(e,(a>>>27)|(a<<5),b^c^d,w[j],k4);
                    e=d; d=c; c=(b>>>2)|(b<<30); b=a; a = t;
                }

                h0 = add32(h0,a);
                h1 = add32(h1,b);
                h2 = add32(h2,c);
                h3 = add32(h3,d);
                h4 = add32(h4,e);
            }
            return Array(h0,h1,h2,h3,h4);
        };

    //
    // chips helpers
    //
    jpoker.chips = {
        epsilon: 0.001,
        fraction: '.',
        thousand: ',',
        thousand_re: new RegExp(/(\d+)(\d\d\d)/),

        chips2value: function(chips) {
            var value = 0;
            for(var i = 0; i < chips.length; i += 2) {
                value += ( chips[i] / 100 ) * chips[i + 1];
            }
            return value;
        },

        SHORT: function(chips) {
            if(chips < 10) {
                return this.LONG(chips);
            }
            var unit = [ 'G', 'M', 'K', '' ];
            for(var magnitude = 1000000000; magnitude > 0; magnitude /= 1000) {
                if(chips >= magnitude) {
                    if(chips / magnitude < 10) {
                        chips = chips / ( magnitude / 10 );
                        return parseInt(chips / 10, 10) + this.fraction + parseInt(chips % 10, 10) + unit[0];
                    } else {
                        return parseInt(chips / magnitude, 10) + unit[0];
                    }
                }
                unit.shift();
            }
        },

        LONG: function(chips) {
            var chips_fraction = parseInt(chips * 100, 10) % 100;
            var chips_str = String(parseInt(chips, 10));
            var replacement = '$1' + this.thousand + '$2';
            while(this.thousand_re.test(chips_str)) {
                chips_str = chips_str.replace(this.thousand_re, replacement);
            }
            if(chips_fraction === 0) {
                return chips_str;
            } else if(chips_fraction % 10) {
                if(chips_fraction < 10) {
                    return chips_str + '.0' + chips_fraction;
                } else {
                    return chips_str + '.' + chips_fraction;
                }
            } else {
                return chips_str + '.' + parseInt(chips_fraction / 10, 10);
            }
        }

    };

    //
    // cards helpers
    //
    jpoker.cards = {
        // Ad replaced with Ax to escape adblock
        card2string: [ '2h', '3h', '4h', '5h', '6h', '7h', '8h', '9h', 'Th', 'Jh', 'Qh', 'Kh', 'Ah', '2d', '3d', '4d', '5d', '6d', '7d', '8d', '9d', 'Td', 'Jd', 'Qd', 'Kd', 'Ax', '2c', '3c', '4c', '5c', '6c', '7c', '8c', '9c', 'Tc', 'Jc', 'Qc', 'Kc', 'Ac', '2s', '3s', '4s', '5s', '6s', '7s', '8s', '9s', 'Ts', 'Js', 'Qs', 'Ks', 'As' ]
    };

    //
    // Abstract prototype for all objects that
    // call destroy and update callbacks
    //
    jpoker.watchable = function(options) {
        $.extend(this, jpoker.watchable.defaults, options);
        if(jpoker.verbose > 0) {
            this.uid = jpoker.uid(); // helps track the packets
        }
        this.init();
    };

    jpoker.watchable.defaults = {
    };

    jpoker.watchable.prototype = {

        init: function() {
            this.setCallbacks();
        },

        uninit: function(arg) {
            this.notifyDestroy(arg);
            this.setCallbacks();
        },

        setCallbacks: function() {
            this.callbacks = { };
            this.protect = { };
        },

        notify: function(what, data) {
            if(what in this.callbacks) {
                if(what in this.protect) {
                    throw 'notify recursion for ' + what;
                }
                this.protect[what] = [];
                var result = [];
                var l = this.callbacks[what];
                for(var i = 0; i < l.length; i++) {
                    if(l[i](this, what, data)) {
                        result.push(l[i]);
                    }
                }
                this.callbacks[what] = result;
                var backlog = this.protect[what];
                delete this.protect[what];
                for(var j = 0; j < backlog.length; j++) {
                    backlog[j]();
                }
            }
        },

        notifyUpdate: function(data) { this.notify('update', data); },
        notifyDestroy: function(data) { this.notify('destroy', data); },
        notifyReinit: function(data) { this.notify('reinit', data); },

        register: function(what, callback, callback_data, signature) {
            if(what in this.protect) {
                var self = this;
                this.protect[what].push(function() {
                        self.register(what, callback, callback_data, signature);
                    });
            } else {
                this.unregister(what, signature || callback);
                if(!(what in this.callbacks)) {
                    this.callbacks[what] = [];
                }
                var wrapper = function($this, what, data) {
                    return callback($this, what, data, callback_data);
                };
                wrapper.signature = signature || callback;
                this.callbacks[what].push(wrapper);
            }
        },

        registerUpdate: function(callback, callback_data, signature) { this.register('update', callback, callback_data, signature); },
        registerDestroy: function(callback, callback_data, signature) { this.register('destroy', callback, callback_data, signature); },
        registerReinit: function(callback, callback_data, signature) { this.register('reinit', callback, callback_data, signature); },

        unregister: function(what, signature) {
            if(what in this.callbacks) {
                this.callbacks[what] = $.grep(this.callbacks[what],
                                              function(e, i) { return e.signature != signature; });
                if(this.callbacks[what].length <= 0) {
                    delete this.callbacks[what];
                }
            }
        },

        unregisterUpdate: function(callback) { this.unregister('update', callback); },
        unregisterDestroy: function(callback) { this.unregister('destroy', callback); },
        unregisterReinit: function(callback) { this.unregister('reinit', callback); }

    };

    //
    // Abstract prototype to manage the communication with a single poker server
    //
    jpoker.connection = function(options) {
        $.extend(this, jpoker.connection.defaults, options);
        this.init();
    };

    jpoker.connection.defaults = $.extend({
            url: '',
            async: true,
            lagmax: 15000,
            dequeueFrequency: 100,
            longPollFrequency: 100,
            minLongPollFrequency: 30,
            timeout: 30000,
            retryCount: 10,
            clearTimeout: function(id) { return window.clearTimeout(id); },
            setTimeout: function(cb, delay) { return window.setTimeout(cb, delay); },
            ajax: function(o) { return jQuery.ajax(o); },
            protocol: function() { return document.location.protocol; }
        }, jpoker.watchable.defaults);

    jpoker.connection.prototype = $.extend({}, jpoker.watchable.prototype, {

            LOGIN: 'loging',
            RUNNING: 'running',
            QUITTING: 'quitting',
            USER_INFO: 'retrieving user info',
            RECONNECT: 'trying to reconnect',
            MY: 'searching my tables',
            TABLE_LIST: 'searching tables',
            TOURNEY_LIST: 'searching tourneys',
            TOURNEY_DETAILS: 'retrieving tourney details',
            TABLE_JOIN: 'joining table',
            TABLE_PICK: 'picking table',
            TABLE_QUIT: 'quitting table',
            TOURNEY_REGISTER: 'updating tourney registration',
            PERSONAL_INFO: 'getting personal info',
            CREATE_ACCOUNT: 'creating account',
            PLACES: 'getting player places',
            STATS: 'getting player stats',
            LOCALE: 'setting locales',

            blocked: false,

            lag: 0,

            high: ['PacketPokerChat', 'PacketPokerMessage', 'PacketPokerGameMessage'],

            incomingTimer: -1,

            longPollTimer: -1,

            init: function() {
                jpoker.watchable.prototype.init.call(this);
                this.queues = {};
                this.delays = {};
                this.auth = 'auth=' + this.getAuthHash();
                this.session_uid = 'uid=' + jpoker.Crypto.hexSha1Str(this.url + Math.random());

                if (this.urls === undefined) {
                    this.urls = {};
                }
                if (this.urls.avatar === undefined) {
                    this.urls.avatar = this.url.substr(0, this.url.lastIndexOf('/')+1) + 'AVATAR';
                }
                if (this.urls.upload === undefined) {
                    this.urls.upload = this.url.substr(0, this.url.lastIndexOf('/')+1) + 'UPLOAD?' + this.auth;
                }
                this.reset();
            },

            uninit: function() {
                this.blocked = true;
                jpoker.watchable.prototype.uninit.call(this);
                this.reset();
            },

            getAuthHash: function() {
                var auth_cookie = 'JPOKER_AUTH_' + jpoker.url2hash(this.url);
                var auth_hash = $.cookie(auth_cookie);
                if(auth_hash === null) {
                    auth_hash = jpoker.Crypto.hexSha1Str(this.url + Math.random());
                    var expires = new Date();
                    expires.setTime(expires.getTime() + self.authExpires);
                    //$.cookie(auth_cookie, auth_hash, { expires: expires, path: '/' } );
                    $.cookie(auth_cookie, auth_hash, { path: '/' } );
                } else {
                    this.foundAuthCookie = true;
                }
                return auth_hash;
            },

            reset: function() {
                this.clearTimeout(this.longPollTimer);
                this.longPollTimer = -1;
                this.pendingLongPoll = false;
                this.clearTimeout(this.incomingTimer);
                this.incomingTimer = -1;
                // empty the outgoing queue
                jQuery([$.ajax_queue]).queue('ajax', []);
                // empty the incoming queue
                this.queues = {};
                this.delays = {};
                this.sentTime = 0;
                this.connectionState = 'disconnected';
                this.longPoll();
            },

            quit: function() {
                this.longPollFrequency = -1;
            },

            error: function(reason) {
                jpoker.watchable.prototype.setCallbacks.call(this);
                jpoker.connection.prototype.quit.call(this);
                this.reset();
                this.setConnectionState('disconnected');
                jpoker.error(reason);
            },

            setConnectionState: function(state) {
                if(this.connectionState != state) {
                    this.connectionState = state;
                    this.notifyUpdate({type: 'PacketConnectionState', state: state});
                }
            },

            getConnectionState: function() {
                return this.connectionState;
            },

            connected: function() {
                return this.getConnectionState() == 'connected';
            },

            //
            // Call 'handler' for each packet sent to the poker game 'id'
            // If id == 0, 'handler' is called for each packet not associated with
            // a poker game.
            //
            // Prototype: handler(server, id, packet) returns a boolean
            //
            // server: the $.jpoker.server instance connected to the server from
            //        which the packet was received
            // id: is 0 if the packet is not associated to a poker game or the serial
            //     number of the poker game
            // packet: is the packet received from the server
            //
            // If the return value of the handler function is false,
            // the handler is discarded and will not
            // be called again. If the return value is true, the handler is retained
            // and will be called when the next packet matching the 'id' parameter
            // arrives.
            //
            // If the handler throws an exception, the server will be killed and
            // all communications interrupted. The handler must NOT call server.error,
            // it must throw an exception whenever a fatal error occurs.
            //
            registerHandler: function(id, handler, handler_data, signature) {
                this.register(id, handler, handler_data, signature);
            },

            unregisterHandler: function(id, handler) {
                this.unregister(id, handler);
            },

            handle: function(id, packet) {
                if(jpoker.verbose > 1) {
                    jpoker.message('connection handle ' + id + ': ' + JSON.stringify(packet));
                }
                if(id in this.callbacks) {
                    delete packet.time__;
                    if(jpoker.verbose > 1) {
                        //
                        // For debugging purposes associate a unique ID to each packet in
                        // order to track it in the log messages.
                        //
                        packet.uid__ = jpoker.uid();
                    }
                    try {
                        this.notify(id, packet);
                    } catch(e) {
                        this.error(e); // delegate exception handling to the error function
                        return false; // error will throw and this statement will never be reached
                    }
                    return true;
                } else {
                    return false;
                }
            },

            delayQueue: function(id, time) {
                this.delays[id] = time;
            },

            noDelayQueue: function(id) {
                if(id in this.delays) {
                    delete this.delays[id];
                }
            },

            // null => no delay
            handleDelay: function(id) {
                if(id in this.delays) {
                    return this.delays[id];
                } else {
                    return null;
                }
            },

            sendPacket: function(packet, callback) {
                if(this.pendingLongPoll) {
                    if(jpoker.verbose > 0) {
                        jpoker.message('sendPacket PacketPokerLongPollReturn');
                    }
                    this.sendPacketAjax({ type: 'PacketPokerLongPollReturn' }, 'direct');
                }
                this.sendPacketAjax(packet, 'queue', callback);
                if(packet.type == 'PacketPokerLongPoll') {
                    this.pendingLongPoll = true;
                }
            },

            receivePacket: function(data) {
                if(this.pendingLongPoll) {
                    this.scheduleLongPoll(0);
                }
                this.pendingLongPoll = false;
                this.queueIncoming(data);
            },

            sendPacketAjax: function(packet, mode, callback) {
                var $this = this;
                var json_data = JSON.stringify(packet);
                if(jpoker.verbose > 0) {
                    jpoker.message('sendPacket ' + json_data);
                }
                var packet_type = packet.type;
                var retry = 0;
                var args = {
                    async: this.async,
                    data: json_data,
                    mode: mode,
                    timeout: this.timeout,
                    url: this.url + '?' + this.auth + '&' + this.session_uid,
                    type: 'POST',
                    dataType: 'json',
                    global: false, // do not fire global events
                    success: function(data, status) {
                        if(jpoker.verbose > 0) {
                            jpoker.message('success ' + json_data + ' returned ' + data);
                        }
                        if($this.getConnectionState() != 'connected') {
                            $this.setConnectionState('connected');
                        }
                        if(packet_type != 'PacketPokerLongPollReturn') {
                            $this.receivePacket(data);
                        }
                        if (callback !== undefined) {
                            callback(data, status);
                        }
                    },
                    error: function(xhr, status, error) {
                        if(jpoker.verbose > 0) {
                            jpoker.message('error callback fire for ' + json_data);
                        }
                        if(status == 'timeout') {
                            $this.setConnectionState('disconnected');
                            $this.reset();
                        } else {
                            switch (xhr.status) {
                            case 0: // when the browser aborts xhr ( unload for instance )
                            return; // discard the error
                            case 12152:
                            case 12030:
                            case 12031:
                             ++retry;
                            if (retry < $this.retryCount) {
                                return false; // retry
                            }
                            error = 'ajax retry count exceeded: '+ retry;
                            break;
                            }
                            $this.error({ xhr: xhr,
                                          status: status,
                                          url: $this.url,
                                          error: error
                                });
                        }
                    }
                };
                this.sentTime = jpoker.now();
                this.ajax(args);
            },

            longPoll: function() {
                if(this.longPollFrequency > 0) {
                    var delta = jpoker.now() - this.sentTime;
                    var in_line = jQuery([$.ajax_queue]).queue('ajax').length;
                    if(in_line <= 0 &&
                       delta > this.longPollFrequency) {
                        this.clearTimeout(this.longPollTimer);
                        this.longPollTimer = -1;
                        this.sendPacket({ type: 'PacketPokerLongPoll' });
                    } else {
                        this.scheduleLongPoll(delta > 0 ? delta : 0);
                    }
                }
            },

            scheduleLongPoll: function(delta) {
                this.clearTimeout(this.longPollTimer);
                var $this = this;
                this.longPollTimer = this.setTimeout(
                    function() {
                        $this.longPoll();
                    }, Math.max(this.minLongPollFrequency, this.longPollFrequency - delta));
            },

            queueIncoming: function(packets) {
                if(!this.blocked) {
                    for(var i = 0; i < packets.length; i++) {
                        packet = packets[i];
                        if('session' in packet) {
                            delete packet.session;
                        }
                        packet.time__ = jpoker.now();
                        var id;
                        if('game_id' in packet) {
                            id = packet.game_id;
                        } else {
                            id = 0;
                        }
                        if(!(id in this.queues)) {
                            this.queues[id] = { 'high': {'packets': [],
                                                         'delay': 0 },
                                                'low': {'packets': [],
                                                        'delay': 0 } };
                        }
                        var queue;
                        if(jQuery.inArray(packet.type, this.high) >= 0) {
                            queue = this.queues[id].high;
                        } else {
                            queue = this.queues[id].low;
                        }
                        queue.packets.push(packet);
                        if(jpoker.verbose > 1) {
                            jpoker.message('queueIncoming ' + JSON.stringify(packet));
                        }
                    }
                    this.clearTimeout(this.incomingTimer);
                    var $this = this;
                    this.incomingTimer = this.setTimeout(function() {
                            $this.dequeueIncoming(); },
                        this.dequeueFrequency);
                }
            },

            dequeueIncoming: function() {
                if(!this.blocked) {
                    now = jpoker.now();
                    this.lag = 0;

                    for(var id in this.queues) {
                        for(var priority in this.queues[id]) {
                            var queue = this.queues[id][priority];
                            if(queue.packets.length <= 0) {
                                continue;
                            }
                            lag = now - queue.packets[0].time__;
                            this.lag = this.lag > lag ? this.lag : lag;
                            if(queue.delay > now && lag > this.lagmax) {
                                queue.delay = 0;
                            }
                            if(queue.delay <= now) {
                                delay = this.handleDelay(id);
                                if(lag > this.lagmax || delay === null || delay <= now) {
                                    if(this.handle(id, queue.packets[0])) {
                                        queue.packets.shift();
                                    }
                                } else {
                                    queue.delay = delay;
                                }
                            } else if(jpoker.verbose > 0) {
                                jpoker.message(_("wait for {delay}s for queue {id}").supplant({ 'delay': queue.delay / 1000.0, 'id': id}));
                            }
                        }
                        //
                        // get rid of queues with no associated delay AND no pending packets.
                        // this.queues may be undefined if a handler destroyed the object
                        //
                        if(id in this.queues) {
                            queue = this.queues[id];
                            if(queue.high.packets.length <= 0 && queue.low.packets.length <= 0) {
                                if(queue.high.delay <= now && queue.low.delay <= now) {
                                    delete this.queues[id];
                                }
                            }
                        }
                    }
                }
                var empty = true;
                for(var j in this.queues) {
                    empty = false;
                    break;
                }
                this.clearTimeout(this.incomingTimer);
                if(!empty) {
                    var $this = this;
                    this.incomingTimer = this.setTimeout(function() {
                            $this.dequeueIncoming(); },
                        this.dequeueFrequency);
                }
            }

        });

    //
    // server
    //
    jpoker.server = function(options) {
        $.extend(this, jpoker.server.defaults, options);
        this.init();
    };

    jpoker.server.defaults = $.extend({
            playersCount: null,
            tablesCount: null,
            playersTourneysCount: null,
            tourneysCount: null,
            spawnTable: function(server, packet) {},
            placeTourneyRowClick: function(server, packet) {},
            placeChallengeClick: function(server, serial) {
                server.sendPacket({
                        type: 'PacketPokerCreateTourney',
                        serial: server.serial,
                        name: server.serial + 'versus' + serial,
                        players: [ server.serial, serial ]
                    });
            },
            tourneyRowClick: function(server, packet) {},
            rankClick: function(server, tourney_serial) {},
            reconnectFinish: function(server) {},
            setInterval: function(cb, delay) { return window.setInterval(cb, delay); },
            clearInterval: function(id) { return window.clearInterval(id); },
            authExpires: 60 * 60 * 1000 // auth cookie expires after 1 hour by default
        }, jpoker.connection.defaults);

    jpoker.server.prototype = $.extend({}, jpoker.connection.prototype, {
            init: function() {
                jpoker.connection.prototype.init.call(this);
                this.tables = {};
                this.tableLists = {};
                this.timers = {};
                this.serial = 0;
                this.userInfo = {};
                this.preferences = new jpoker.preferences(jpoker.url2hash(this.url));
                this.registerHandler(0, this.handler);
                if(jpoker.doReconnect && (jpoker.doReconnectAlways || this.foundAuthCookie || this.protocol() == 'file:')) {
                    this.reconnect();
                }
            },

            uninit: function() {
                this.clearTimers();
                this.unregisterHandler(0, this.handler);
                $.each(this.tables, function(game_id, table) {
                        table.uninit();
                    });
                this.tables = {};
                jpoker.connection.prototype.uninit.call(this);
            },

            reset: function() {
                this.clearTimers();
                jpoker.connection.prototype.reset.call(this);
                this.stateQueue = [];
                this.setState(this.RUNNING, 'reset');
            },

            quit: function(callback) {
                this.queueRunning(function(server) {
                        jpoker.connection.prototype.quit.call(server);
                        server.setState(server.QUITTING, 'quit');
                        server.sendPacket({ type: 'PacketQuit' }, 
                                          function() {
                                              server.uninit();
                                              if (callback !== undefined) {
                                                  callback(server);
                                              }
                                          });
                    });
            },

            queueRunning: function(callback) {
                this.stateQueue.push(callback);
                this.dequeueRunning();
            },

            dequeueRunning: function() {
                while(this.stateQueue.length > 0 && this.state == this.RUNNING) {
                    var callback = this.stateQueue.shift();
                    callback(this);
                }
            },

            setState: function(state, comment) {
                if(this.state != state) {
                    this.state = state;
                    if(!state) {
                        jpoker.error('undefined state');
                    }
                    if(jpoker.verbose > 0) {
                        jpoker.message('setState ' + state + ' ' + comment);
                    }
                    this.notifyUpdate({type: 'PacketState', state: state});
                    this.dequeueRunning();
                }
            },

            getState: function() {
                return this.state;
            },

            clearTimers: function() {
                var $this = this;
                if (this.timers) {
                    $.each(this.timers, function(key, value) {
                            $this.clearInterval(value.timer);
                        });
                    this.timers = {};
                }
            },

            handler: function(server, game_id, packet) {
                if(jpoker.verbose > 0) {
                    jpoker.message('server.handler ' + JSON.stringify(packet));
                }

                switch(packet.type) {

                case 'PacketPokerTourneyStart':
                server.tableJoin(packet.table_serial);
                break;

                case 'PacketPokerTable':
                if(packet.id in server.tables) {
                    server.tables[packet.id].reinit(packet);
                } else {
                    var table = new jpoker.table(server, packet);
                    server.tables[packet.id] = table;
                    server.notifyUpdate(packet);
                }
                packet.game_id = packet.id;
                server.spawnTable(server, packet);
                break;

                case 'PacketPokerMessage':
                case 'PacketPokerGameMessage':
                jpoker.dialog(packet.string);
                break;

                case 'PacketSerial':
                server.setSerial(packet);
                break;

                case 'PacketPokerPlayerInfo':
                server.userInfo = packet;
                break;

                case 'PacketPokerUserInfo':
                server.userInfo = packet;
                for(id in server.tables) {
                    packet.game_id = id;
                    server.tables[id].handler(server, game_id, packet);
                    server.tables[id].notifyUpdate(packet);
                }
                delete packet.game_id;
                server.notifyUpdate(packet);
                server.setState(server.RUNNING, 'PacketPokerUserInfo');
                break;

                case 'PacketPokerPlayerStats':
                for (id in server.tables) {
                    packet.game_id = id;
                    server.tables[id].handler(server, id, packet);
                }
                delete packet.game_id;
                break;

                }

                return true;
            },

            setSerial: function(packet) {
                this.serial = packet.serial;
                var id;
                for(id in this.tables) {
                    this.tables[id].notifyUpdate(packet);
                }
            },

            reconnect: function() {
                this.setState(this.RECONNECT);
                //
                // the answer to PacketPokerGetPlayerInfo gives back the serial, if and
                // only if the session is still valid. Otherwise it returns an error
                // packet and the session must be re-initialized.
                //
                var handler = function(server, game_id, packet) {
                    if(packet.type == 'PacketPokerPlayerInfo') {
                        server.setSerial({ type: 'PacketSerial', serial: packet.serial });
                        if (jpoker.doRejoin) {
                            server.rejoin();
                        } else {
                            server.setState(server.RUNNING, 'no rejoin');
                        }
                        return false;
                    } else if(packet.type == 'PacketError') {
                        if(packet.other_type != jpoker.packetName2Type.POKER_GET_PLAYER_INFO) {
                            jpoker.error('unexpected error while reconnecting ' + JSON.stringify(packet));
                        }
                        server.setState(server.RUNNING, 'PacketError reconnect');
                        return false;
                    }
                    return true;
                };
                this.registerHandler(0, handler);
                this.sendPacket({ type: 'PacketPokerGetPlayerInfo' });
            },

            refresh: function(tag, request, handler, state, options) {
                var timerRequest = jpoker.refresh(this, request, handler, state, options);
                if(timerRequest.timer) {
                    if(tag in this.timers) {
                        this.clearInterval(this.timers[tag].timer);
                    }
                    this.timers[tag] = timerRequest;
                }
                return timerRequest;
            },

            stopRefresh: function(tag) {
                if (this.timers[tag] !== undefined) {
                    this.clearInterval(this.timers[tag].timer);
                    delete this.timers[tag];
                }
            },

            //
            // tables lists
            //
            refreshTables: function(string, options) {

                if(!(string in this.tables)) {
                    this.tableLists[string] = {};
                }

                var request = function(server) {
                    server.sendPacket({
                            type: 'PacketPokerTableSelect',
                            string: string
                        });
                };

                var handler = function(server, packet) {
                    var info = server.tableLists && server.tableLists[string];
                    if(packet.type == 'PacketPokerTableList') {
                        info.packet = packet;
                        // although the tables/players count is sent with each
                        // table list, it is global to the server
                        server.playersCount = packet.players;
                        server.tablesCount = packet.tables;
                        server.notifyUpdate(packet);
                        return false;
                    }
                    return true;
                };

                return this.refresh('tableList', request, handler, this.TABLE_LIST, options);
            },

            //
            // table information
            //
            tableInformation: function(game_id, callback) {
                this.queueRunning(function(server) {
                                      server.setState(server.TABLE_JOIN, 'tableInformation');
                                      var users = {};
                                      var spawnTable = server.spawnTable;
                                      var handler = function(server, game_id, packet) {
                                          if(packet.type == 'PacketPokerPlayerArrive') {
                                              users[packet.serial] = { name: packet.name, seat: packet.seat, serial: packet.serial };
                                          } else if(packet.type == 'PacketPokerPlayerChips') {
                                              users[packet.serial].chips = packet.money;
                                          } else if(packet.type == 'PacketPokerStreamMode') {
                                              server.spawnTable = spawnTable;
                                              server.tables[game_id].handler(server, game_id,
                                                                             { type: 'PacketPokerTableDestroy',
                                                                               game_id: game_id });
                                              server.setState(server.RUNNING, 'tableInformation');
                                              var table_info = [];
                                              for(serial in users) {
                                                  table_info.push(users[serial]);
                                              }
                                              callback(server, table_info);
                                              return false;
                                          }
                                          return true;
                                      };
                                      server.spawnTable = function() { };
                                      server.registerHandler(game_id, handler);
                                      server.sendPacket({ type: 'PacketPokerTableJoin',
                                                          game_id: game_id });
                                  });
            },

            //
            // tourneys lists
            //
            refreshTourneys: function(string, options) {

                var request = function(server) {
                    server.sendPacket({
                            type: 'PacketPokerTourneySelect',
                            string: string
                        });
                };

                var handler = function(server, packet) {
                    if(packet.type == 'PacketPokerTourneyList') {
                        // although the tourneys/players count is sent with each
                        // tourney list, it is global to the server
                        server.playersTourneysCount = packet.players;
                        server.tourneysCount = packet.tourneys;
                        server.notifyUpdate(packet);
                        return false;
                    }
                    return true;
                };

                return this.refresh('tourneyList', request, handler, this.TOURNEY_LIST, options);
            },

            //
            // tourney details
            //
            refreshTourneyDetails: function(game_id, options) {

                var request = function(server) {
                    server.sendPacket({
                            type: 'PacketPokerGetTourneyManager',
                            tourney_serial: game_id
                        });
                };

                var handler = function(server, packet) {
                    if(packet.type == 'PacketPokerTourneyManager') {
                        // although the tourneys/players count is sent with each
                        // tourney list, it is global to the server
                        server.notifyUpdate(packet);
                        return false;
                    }
                    return true;
                };

                return this.refresh('tourneyDetails', request, handler, this.TOURNEY_DETAILS, options);
            },

            //
            // login / logout
            //
            loggedIn: function() {
                return this.serial !== 0;
            },

            login: function(name, password) {
                if(this.serial !== 0) {
                    throw _("{url} attempt to login {name} although serial is {serial} instead of 0").supplant({ 'url': this.url, 'name': name, 'serial': this.serial});
                }
                this.setState(this.LOGIN);
                this.userInfo.name = name;
                this.sendPacket({
                        type: 'PacketLogin',
                        name: name,
                        password: password
                    });
                this.getUserInfo(); // will fire when login is complete
                var answer = function(server, game_id, packet) {
                    switch(packet.type) {

                    case 'PacketAuthOk':
                    return true;

                    case 'PacketAuthRefused':
                    jpoker.dialog(_(packet.message) + _(" (login name is {name} )").supplant({ 'name': name }));
                    server.notifyUpdate(packet);
                    server.setState(server.RUNNING, 'PacketAuthRefused');
                    return false;

                    case 'PacketError':
                    if(packet.other_type == jpoker.packetName2Type.LOGIN) {
                        jpoker.dialog(_("user {name} is already logged in".supplant({ 'name': name })));
                        server.notifyUpdate(packet);
                    }
                    server.setState(server.RUNNING, 'login PacketError');
                    return false;

                    case 'PacketSerial':
                    server.notifyUpdate(packet);
                    server.setState(server.RUNNING, 'login serial received');
                    return false;
                    }

                    return true;
                };
                this.registerHandler(0, answer);
            },

            logout: function() {
                if(this.serial !== 0) {
                    //
                    // redundant with PacketLogout handler in server to ensure all
                    // notify functions will see serial == 0 regardless of the
                    // order in which they are called.
                    //
                    this.serial = 0;
                    this.userInfo = {};
                    var packet = { type: 'PacketLogout' };
                    this.sendPacket(packet);
                    //
                    // LOGOUT IMPLIES ALL TABLES ARE DESTROYED INSTEAD
                    //
                    for(var game_id in this.tables) {
                        this.tables[game_id].notifyUpdate(packet);
                    }
                    this.notifyUpdate(packet);
                }
            },

            getUserInfo: function() {
                this.queueRunning(function(server) {
                        server.setState(server.USER_INFO);
                        server.sendPacket({
                                type: 'PacketPokerGetUserInfo',
                                    serial: server.serial });
                    });
            },

            rejoin: function() {
                this.setState(this.MY);
                var handler = function(server, game_id, packet) {
                    if(packet.type == 'PacketPokerPlayerPlaces') {
                        for(var i = 0; i < packet.tables.length; i++) {
                            var table_id = packet.tables[i];
                            server.tableJoin(table_id);
                        }
                        server.getUserInfo();
                        server.queueRunning(function(server) { server.reconnectFinish(server); });
                        server.setState(server.RUNNING, 'rejoin');
                        return false;
                    }
                    return true;
                };
                this.registerHandler(0, handler);
                this.sendPacket({ type: 'PacketPokerGetPlayerPlaces', serial: this.serial });
            },

            tableJoin: function(game_id) {
                this.queueRunning(function(server) {
                        server.setState(server.TABLE_JOIN);
                        server.sendPacket({ 'type': 'PacketPokerTableJoin',
                                    'game_id': game_id });
                    });
            },

            tablePick: function(criterion) {
                if (this.loggedIn() === false) {
                    jpoker.dialog(_("User must be logged in"));
                } else {
                    this.queueRunning(function(server) {
                            server.setState(server.TABLE_PICK);
                            var packet = $.extend(criterion, {
                                    type: 'PacketPokerTablePicker',
                                    serial: server.serial,
                                    auto_blind_ante: true
                                });
                            if (packet.variant === '') {
                                delete packet.variant;
                            }
                            if (packet.betting_structure === '') {
                                delete packet.betting_structure;
                            }
                            if (packet.currency_serial !== undefined) {
                                packet.currency_serial = parseInt(packet.currency_serial, 10);
                            } else {
                                delete packet.currency_serial;
                            }
                            server.sendPacket(packet);
                            server.registerHandler(0, function(server, unused_game_id, packet) {
                                    if ((packet.type == 'PacketPokerTable') &&
                                        (packet.reason == 'TablePicker')) {
                                        server.setState(server.RUNNING, 'PacketPokerTable');
                                        return false;
                                    } else if ((packet.type == 'PacketPokerError') &&
                                               (packet.other_type == jpoker.packetName2Type.POKER_TABLE_PICKER)) {
                                        server.notifyUpdate(packet);
                                        server.setState(server.RUNNING, 'PacketPokerError');
                                        return false;
                                    }
                                    return true;
                                });
                        });
                }
            },

            tableQuit: function(game_id) {
                if (this.loggedIn() === false) {
                    jpoker.dialog(_("User must be logged in"));
                } else {
                    this.queueRunning(function(server) {
                            server.setState(server.TABLE_QUIT);
                            server.sendPacket({ type: 'PacketPokerTableQuit', game_id: game_id }, function() {
                                    server.setState(server.RUNNING, 'PacketPokerTableQuit');
                                });
                        });
                }
            },

            bankroll: function(currency_serial) {
                var key = 'X' + currency_serial;
                if(this.loggedIn() && 'money' in this.userInfo && key in this.userInfo.money) {
                    return this.userInfo.money[key][0] / 100; // PacketPokerUserInfo for documentation
                }
                return 0;
            },

            tourneyRegister: function(game_id) {
                this.queueRunning(function(server) {
                        server.setState(server.TOURNEY_REGISTER);
                        server.sendPacket({'type': 'PacketPokerTourneyRegister', 'serial': server.serial, 'game_id' : game_id});
                        server.registerHandler(game_id, function(server, game_id, packet) {
                                if (packet.type == 'PacketPokerTourneyRegister') {
                                    server.notifyUpdate(packet);
                                    server.queueRunning(function() {
                                            if (server.timers.tourneyDetails !== undefined) {
                                                server.timers.tourneyDetails.request();
                                            }
                                        });
                                    server.setState(server.RUNNING, 'PacketPokerTourneyRegister');
                                    return false;
                                }
                                return true;
                            });
                        server.registerHandler(0, function(server, unused_game_id, packet) {
                                if ((packet.type == 'PacketError') && (packet.subpacket == jpoker.packetName2Type.PACKET_POKER_TOURNEY_REGISTER)) {
                                    var code2message = {
                                        1:_("Tournament {game_id} does not exist"),
                                        2:_("Player {serial} already registered in tournament {game_id}"),
                                        3:_("Registration refused in tournament {game_id}"),
                                        4:_("Not enough money to enter the tournament {game_id}")};
                                    if (code2message[packet.code] !== undefined) {
                                        packet.message = code2message[packet.code].supplant({game_id: game_id, serial: server.serial});
                                    }
                                    jpoker.dialog(packet.message);
                                    server.notifyUpdate(packet);
                                    server.setState(server.RUNNING, 'PacketError');
                                    return false;
                                }
                                return true;
                            });
                    });
            },

            tourneyUnregister: function(game_id) {
                this.queueRunning(function(server) {
                        server.setState(server.TOURNEY_REGISTER);
                        server.sendPacket({'type': 'PacketPokerTourneyUnregister', 'serial': server.serial, 'game_id' : game_id});
                        server.registerHandler(game_id, function(server, game_id, packet) {
                                if (packet.type == 'PacketPokerTourneyUnregister') {
                                    server.notifyUpdate(packet);
                                    server.queueRunning(function() {
                                            if (server.timers.tourneyDetails !== undefined) {
                                                server.timers.tourneyDetails.request();
                                            }
                                        });
                                    server.setState(server.RUNNING, 'PacketPokerTourneyUnregister');
                                    return false;
                                }
                                return true;
                            });
                        server.registerHandler(0, function(server, unused_game_id, packet) {
                                if ((packet.type == 'PacketError') && (packet.subpacket == jpoker.packetName2Type.PACKET_POKER_TOURNEY_UNREGISTER)) {
                                    var code2message = {
                                        1: _("Tournament {game_id} does not exist"),
                                        2: _("Player {serial} is not registered in tournament {game_id}"),
                                        3: _("It is too late to unregister player {serial} from tournament {game_id}")};
                                    if (code2message[packet.code] !== undefined) {
                                        packet.message = code2message[packet.code].supplant({game_id: game_id, serial: server.serial});
                                    }
                                    jpoker.dialog(_(packet.message));
                                    server.notifyUpdate(packet);
                                    server.setState(server.RUNNING, 'PacketError');
                                    return false;
                                }
                                return true;
                            });
                    });
            },

            getPersonalInfo : function() {
                if (this.loggedIn())  {
                    this.queueRunning(function(server) {
                            server.setState(server.PERSONAL_INFO);
                            server.sendPacket({'type': 'PacketPokerGetPersonalInfo', 'serial': server.serial});
                            server.registerHandler(0, function(server, unused_game_id, packet) {
                                    if (packet.type == 'PacketPokerPersonalInfo') {
                                        server.notifyUpdate(packet);
                                        server.setState(server.RUNNING, 'PacketPokerPersonalInfo');
                                        return false;
                                    }
                                    return true;
                                });
                        });
                } else {
                    jpoker.dialog(_("User must be logged in"));
                }
            },

            setPersonalInfo : function(info) {
                this.queueRunning(function(server) {
                        if (info.password != info.password_confirmation) {
                            jpoker.dialog(_("Password confirmation does not match"));
                        } else {
                            server.setState(server.PERSONAL_INFO);
                            var personalInfoDefaults = {
                                'type' : 'PacketPokerSetAccount',
                                'serial': server.serial,
                                'name': server.userInfo.name,
                                'password': ''
                            };
                            server.sendPacket($.extend(personalInfoDefaults, info));
                            server.registerHandler(0, function(server, unused_game_id, packet) {
                                    if (packet.type == 'PacketPokerPersonalInfo') {
                                        packet.set_account = true;
                                        server.notifyUpdate(packet);
                                        server.setState(server.RUNNING, 'PacketPokerPersonalInfo');
                                        return false;
                                    }
                                    else if (packet.type == 'PacketError') {
                                        jpoker.dialog(packet.message);
                                        server.notifyUpdate(packet);
                                        server.setState(server.RUNNING, 'PacketError');
                                    }
                                    return true;
                                });
                        }
                    });
            },

            createAccount : function(options) {
                this.queueRunning(function(server) {
                        if (options.password != options.password_confirmation) {
                            jpoker.dialog(_("Password confirmation does not match"));
                        } else {
                            server.setState(server.CREATE_ACCOUNT);
                            var packet = {
                                'type' : 'PacketPokerCreateAccount'
                            };
                            server.sendPacket($.extend(packet, options));
                            server.registerHandler(0, function(server, unused_game_id, packet) {
                                    if (packet.type == 'PacketPokerPersonalInfo') {
                                        server.notifyUpdate(packet);
                                        server.queueRunning(function(server) {
                                                server.login(options.name, options.password);
                                            });
                                        server.setState(server.RUNNING, 'PacketPokerPersonalInfo');
                                        return false;
                                    }
                                    else if (packet.type == 'PacketError') {
                                        jpoker.dialog(packet.message);
                                        server.notifyUpdate(packet);
                                        server.setState(server.RUNNING, 'PacketError');
                                        return false;
                                    }
                                    return true;
                                });
                        }
                    });
            },

            selectTables : function(string) {
                this.queueRunning(function(server) {
                        server.setState(server.TABLE_LIST);
                        server.sendPacket({'type': 'PacketPokerTableSelect', 'string': string});
                        server.registerHandler(0, function(server, unused_game_id, packet) {
                                if (packet.type == 'PacketPokerTableList') {
                                    server.notifyUpdate(packet);
                                    server.setState(server.RUNNING, 'PacketPokerTableList');
                                    return false;
                                }
                                return true;
                            });
                    });
            },

            getPlayerPlaces : function(serial) {
                if ((this.loggedIn() === false) && (serial === undefined)) {
                    jpoker.dialog(_("User must be logged in"));
                }
                else {
                    var player_serial = serial;
                    if (player_serial === undefined) {
                        player_serial = this.serial;
                    }
                    this.queueRunning(function(server) {
                            server.setState(server.PLACES);
                            server.sendPacket({'type': 'PacketPokerGetPlayerPlaces', 'serial': player_serial});
                            server.registerHandler(0, function(server, unused_game_id, packet) {
                                    if (packet.type == 'PacketPokerPlayerPlaces') {
                                        server.notifyUpdate(packet);
                                        server.setState(server.RUNNING, 'PacketPokerPlayerPlaces');
                                        return false;
                                    }
                                    return true;
                                });
                        });
                }
            },

            getPlayerPlacesByName : function(name, options) {
                this.queueRunning(function(server) {
                        server.setState(server.PLACES);
                        server.sendPacket({'type': 'PacketPokerGetPlayerPlaces', 'name': name});
                        server.registerHandler(0, function(server, unused_game_id, packet) {
                                if (packet.type == 'PacketPokerPlayerPlaces') {
                                    server.notifyUpdate(packet);
                                    server.setState(server.RUNNING, 'PacketPokerPlayerPlaces');
                                    return false;
                                } else if ((packet.type == 'PacketError') && (packet.other_type == jpoker.packetName2Type.PACKET_POKER_PLAYER_PLACES)) {
                                    if (options === undefined || options.dialog) {
                                        jpoker.dialog(_("No such user: "+name));
                                    }
                                    server.notifyUpdate(packet);
                                    server.setState(server.RUNNING, 'PacketError');
                                    return false;
                                }
                                return true;
                            });
                    });
            },

            getPlayerStats : function(serial) {
                this.queueRunning(function(server) {
                        server.setState(server.STATS);
                        server.sendPacket({'type': 'PacketPokerGetPlayerStats', 'serial': serial});
                        server.registerHandler(0, function(server, unused_game_id, packet) {
                                if (packet.type == 'PacketPokerPlayerStats') {
                                    server.notifyUpdate(packet);
                                    server.setState(server.RUNNING, 'PacketPokerPlayerStats');
                                    return false;
                                }
                                return true;
                            });
                    });
            },

            setLocale: function(locale, game_id) {
                this.queueRunning(function(server) {
                        server.setState(server.LOCALE);
                        server.sendPacket({'type': 'PacketPokerSetLocale', 'serial': server.serial, 'locale': locale, 'game_id': game_id});
                        server.registerHandler(0, function(server, unused_game_id, packet) {
                                if (packet.type == 'PacketAck') {
                                    server.notifyUpdate(packet);
                                    server.setState(server.RUNNING, 'PacketAck');
                                    return false;
                                }
                                else if (packet.type == 'PacketPokerError' && packet.other_type == jpoker.packetName2Type.PACKET_POKER_SET_LOCALE) {
                                    jpoker.dialog('setLocale failed: ' + packet.message);
                                    server.notifyUpdate(packet);
                                    server.setState(server.RUNNING, 'PacketError');
                                }
                                return true;
                            });
                    });
            }
        });
